module.exports = { contents: "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst React = require(\"react\");\r\nconst TIMER_INTERVAL_MS = 10;\r\nvar GameState;\r\n(function (GameState) {\r\n    GameState[GameState[\"Reset\"] = 0] = \"Reset\";\r\n    GameState[GameState[\"Playing\"] = 1] = \"Playing\";\r\n    GameState[GameState[\"Won\"] = 2] = \"Won\";\r\n    GameState[GameState[\"Lost\"] = 3] = \"Lost\";\r\n})(GameState || (GameState = {}));\r\nvar CellValue;\r\n(function (CellValue) {\r\n    CellValue[CellValue[\"Zero\"] = 0] = \"Zero\";\r\n    CellValue[CellValue[\"One\"] = 1] = \"One\";\r\n    CellValue[CellValue[\"Two\"] = 2] = \"Two\";\r\n    CellValue[CellValue[\"Three\"] = 3] = \"Three\";\r\n    CellValue[CellValue[\"Four\"] = 4] = \"Four\";\r\n    CellValue[CellValue[\"Five\"] = 5] = \"Five\";\r\n    CellValue[CellValue[\"Six\"] = 6] = \"Six\";\r\n    CellValue[CellValue[\"Seven\"] = 7] = \"Seven\";\r\n    CellValue[CellValue[\"Eight\"] = 8] = \"Eight\";\r\n    CellValue[CellValue[\"Bomb\"] = 9] = \"Bomb\";\r\n})(CellValue || (CellValue = {}));\r\nvar CellState;\r\n(function (CellState) {\r\n    CellState[CellState[\"Hidden\"] = 0] = \"Hidden\";\r\n    CellState[CellState[\"Exposed\"] = 1] = \"Exposed\";\r\n    CellState[CellState[\"Flagged\"] = 2] = \"Flagged\";\r\n    CellState[CellState[\"Mistake\"] = 3] = \"Mistake\";\r\n    CellState[CellState[\"Boom\"] = 4] = \"Boom\";\r\n})(CellState || (CellState = {}));\r\nclass CellGrid {\r\n    constructor(rows, cols) {\r\n        this.size = { rows, cols };\r\n        this.cells = CellGrid.init(rows, cols);\r\n        this.flags = 0;\r\n    }\r\n    clone() {\r\n        const newGrid = new CellGrid(this.size.rows, this.size.cols);\r\n        newGrid.cells = this.cells.slice();\r\n        newGrid.flags = this.flags;\r\n        return newGrid;\r\n    }\r\n    mutateFrom(x, y) {\r\n        const newGrid = this.clone();\r\n        newGrid.cells[y] = this.cells[y].slice();\r\n        newGrid.cells[y][x] = { value: this.cells[y][x].value, state: this.cells[y][x].state };\r\n        return newGrid;\r\n    }\r\n    totalCells() {\r\n        return this.cells.length;\r\n    }\r\n    totalRows() {\r\n        return this.size.rows;\r\n    }\r\n    totalCols() {\r\n        return this.size.cols;\r\n    }\r\n    totalFlags() {\r\n        return this.flags;\r\n    }\r\n    incFlags() {\r\n        const newGrid = this.clone();\r\n        newGrid.flags++;\r\n        return newGrid;\r\n    }\r\n    decFlags() {\r\n        const newGrid = this.clone();\r\n        newGrid.flags--;\r\n        return newGrid;\r\n    }\r\n    forEach(fn) {\r\n        for (let y = 0; y < this.size.rows; y++) {\r\n            for (let x = 0; x < this.size.cols; x++) {\r\n                fn.call(this, x, y, this.getCell(x, y));\r\n            }\r\n        }\r\n    }\r\n    reduce(fn, accum) {\r\n        return this.getRows().reduce((accum, row, y) => {\r\n            return row.reduce((accum, cell, x) => {\r\n                return fn.call(this, accum, x, y, this.getCell(x, y));\r\n            }, accum);\r\n        }, accum);\r\n    }\r\n    getRow(y) {\r\n        if (y >= this.size.rows || y < 0 || y % 1 !== 0) {\r\n            return [];\r\n        }\r\n        return this.cells[y];\r\n    }\r\n    getRows() {\r\n        return this.cells;\r\n    }\r\n    hasCell(x, y) {\r\n        if (x < 0 || x >= this.size.cols || y < 0 || y >= this.size.rows) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    getCell(x, y) {\r\n        if (this.hasCell(x, y) === false) {\r\n            throw new Error(`no cell at ${x}x${y}`);\r\n        }\r\n        return this.cells[y][x];\r\n    }\r\n    getCellValue(x, y) {\r\n        if (this.hasCell(x, y) === false) {\r\n            throw new Error(`no cell at ${x}x${y}`);\r\n        }\r\n        return this.cells[y][x].value;\r\n    }\r\n    setCellValue(x, y, value) {\r\n        if (this.hasCell(x, y) === false) {\r\n            throw new Error(`no cell at ${x}x${y}`);\r\n        }\r\n        const newGrid = this.mutateFrom(x, y);\r\n        newGrid.cells[y][x].value = value;\r\n        return newGrid;\r\n    }\r\n    getCellState(x, y) {\r\n        if (this.hasCell(x, y) === false) {\r\n            throw new Error(`no cell at ${x}x${y}`);\r\n        }\r\n        return this.cells[y][x].state;\r\n    }\r\n    setCellState(x, y, state) {\r\n        if (this.hasCell(x, y) === false) {\r\n            throw new Error(`no cell at ${x}x${y}`);\r\n        }\r\n        const newGrid = this.mutateFrom(x, y);\r\n        newGrid.cells[y][x].state = state;\r\n        return newGrid;\r\n    }\r\n    getCellNeighbors(x, y) {\r\n        return [\r\n            { x: x + 0, y: y - 1 },\r\n            { x: x + 0, y: y + 1 },\r\n            { x: x + 1, y: y + 0 },\r\n            { x: x - 1, y: y + 0 },\r\n            { x: x + 1, y: y - 1 },\r\n            { x: x - 1, y: y - 1 },\r\n            { x: x + 1, y: y + 1 },\r\n            { x: x - 1, y: y + 1 },\r\n        ].filter((coord) => {\r\n            const legalX = (coord.x >= 0 && coord.x < this.size.cols);\r\n            const legalY = (coord.y >= 0 && coord.y < this.size.rows);\r\n            return legalX && legalY;\r\n        });\r\n    }\r\n    countNeighborBombs(x, y) {\r\n        const neighbors = this.getCellNeighbors(x, y);\r\n        return neighbors.reduce((accum, coord) => {\r\n            const isBomb = this.getCellValue(coord.x, coord.y) === CellValue.Bomb;\r\n            return accum + (isBomb ? 1 : 0);\r\n        }, 0);\r\n    }\r\n    revealAllBombs() {\r\n        return this.reduce((grid, x, y, cell) => {\r\n            if (cell.value === CellValue.Bomb && cell.state == CellState.Hidden) {\r\n                return grid.setCellState(x, y, CellState.Exposed);\r\n            }\r\n            else if (cell.value !== CellValue.Bomb && cell.state === CellState.Flagged) {\r\n                return grid.setCellState(x, y, CellState.Mistake);\r\n            }\r\n            else {\r\n                return grid;\r\n            }\r\n        }, this);\r\n    }\r\n    detonateBomb(x, y) {\r\n        return this.revealAllBombs()\r\n            .setCellState(x, y, CellState.Boom);\r\n    }\r\n    revealCell(x, y) {\r\n        let grid = this;\r\n        const value = grid.getCellValue(x, y);\r\n        const state = grid.getCellState(x, y);\r\n        const neighbors = grid.getCellNeighbors(x, y);\r\n        if (state === CellState.Hidden) {\r\n            if (value === CellValue.Bomb) {\r\n                return grid.detonateBomb(x, y);\r\n            }\r\n            else {\r\n                grid = grid.setCellState(x, y, CellState.Exposed);\r\n            }\r\n        }\r\n        else {\r\n            return grid;\r\n        }\r\n        if (value === CellValue.Zero) {\r\n            neighbors.forEach((neighbor) => {\r\n                grid = grid.revealCell(neighbor.x, neighbor.y);\r\n            });\r\n        }\r\n        return grid;\r\n    }\r\n    flagCell(x, y) {\r\n        const grid = this;\r\n        const state = grid.getCellState(x, y);\r\n        if (state === CellState.Hidden) {\r\n            return grid.setCellState(x, y, CellState.Flagged).incFlags();\r\n        }\r\n        else if (state === CellState.Flagged) {\r\n            return grid.setCellState(x, y, CellState.Hidden).decFlags();\r\n        }\r\n        else {\r\n            return grid;\r\n        }\r\n    }\r\n    isGameOver() {\r\n        const anyDetonated = this.reduce((anyDetonated, x, y, cell) => {\r\n            if (cell.state === CellState.Boom) {\r\n                return true;\r\n            }\r\n            return anyDetonated;\r\n        }, false);\r\n        if (anyDetonated) {\r\n            return true;\r\n        }\r\n        else {\r\n            const allRevealed = this.reduce((allRevealed, x, y, cell) => {\r\n                if (cell.state === CellState.Hidden) {\r\n                    return false;\r\n                }\r\n                return allRevealed;\r\n            }, true);\r\n            return allRevealed;\r\n        }\r\n    }\r\n    isGameWon() {\r\n        return this.reduce((isWon, x, y, cell) => {\r\n            if (cell.state === CellState.Hidden) {\r\n                return false;\r\n            }\r\n            if (cell.value === CellValue.Bomb && cell.state !== CellState.Flagged) {\r\n                return false;\r\n            }\r\n            return isWon;\r\n        }, true);\r\n    }\r\n    static init(rows, cols) {\r\n        const cells = [];\r\n        for (let y = 0; y < rows; y++) {\r\n            cells[y] = [];\r\n            for (let x = 0; x < cols; x++) {\r\n                cells[y][x] = { value: CellValue.Zero, state: CellState.Hidden };\r\n            }\r\n        }\r\n        return cells;\r\n    }\r\n}\r\nclass GameTable extends React.PureComponent {\r\n    render() {\r\n        return (React.createElement(\"table\", { className: \"game-table\" },\r\n            React.createElement(\"tbody\", null, this.props.children)));\r\n    }\r\n}\r\nclass GameRow extends React.PureComponent {\r\n    render() {\r\n        return (React.createElement(\"tr\", { className: \"game-row\" }, this.props.children));\r\n    }\r\n}\r\nclass GameCell extends React.PureComponent {\r\n    render() {\r\n        const icon = pickIcon(this.props.value, this.props.state);\r\n        const onClick = (event) => { this.props.onClick(event); };\r\n        const onRightClick = (event) => { this.props.onRightClick(event); };\r\n        return React.createElement(\"td\", { className: `game-cell game-cell-state-${icon}`, onClick: onClick, onContextMenu: onRightClick });\r\n    }\r\n}\r\nclass GameStat extends React.PureComponent {\r\n    render() {\r\n        return (React.createElement(\"div\", { className: \"stat\" },\r\n            React.createElement(\"p\", { className: \"value\" }, this.props.value),\r\n            React.createElement(\"p\", { className: \"name\" }, this.props.name)));\r\n    }\r\n}\r\nclass MineSweeper extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.timerClock = null;\r\n        let grid = new CellGrid(props.rows, props.cols);\r\n        grid = addBombs(grid, props.totalBombs);\r\n        grid = addValues(grid);\r\n        this.state = {\r\n            state: GameState.Reset,\r\n            grid: grid,\r\n            moves: 0,\r\n            timer: 0,\r\n        };\r\n    }\r\n    handleCellClick(x, y) {\r\n        return ((event) => {\r\n            event.preventDefault();\r\n            this.updateGame(this.state.grid.revealCell(x, y));\r\n        }).bind(this);\r\n    }\r\n    handleCellRightClick(x, y) {\r\n        return ((event) => {\r\n            event.preventDefault();\r\n            this.updateGame(this.state.grid.flagCell(x, y));\r\n        }).bind(this);\r\n    }\r\n    startGame() {\r\n        this.setState({\r\n            state: GameState.Playing,\r\n            timer: 0,\r\n        });\r\n        this.startClock();\r\n    }\r\n    wonGame(grid) {\r\n        this.setState({\r\n            state: GameState.Won,\r\n            grid: grid.revealAllBombs(),\r\n        });\r\n        this.stopClock();\r\n    }\r\n    lostGame(grid) {\r\n        this.setState({\r\n            state: GameState.Lost,\r\n            grid: grid.revealAllBombs(),\r\n        });\r\n        this.stopClock();\r\n    }\r\n    startClock() {\r\n        this.resetClock();\r\n        this.timerClock = window.setInterval(() => {\r\n            this.setState({\r\n                timer: this.state.timer + TIMER_INTERVAL_MS,\r\n            });\r\n        }, TIMER_INTERVAL_MS);\r\n    }\r\n    resetClock() {\r\n        this.stopClock();\r\n        this.setState({\r\n            timer: 0,\r\n        });\r\n    }\r\n    stopClock() {\r\n        if (this.timerClock !== null) {\r\n            clearInterval(this.timerClock);\r\n        }\r\n        this.timerClock = null;\r\n    }\r\n    splitTime(time) {\r\n        time = Math.round(time);\r\n        const chunks = [];\r\n        while (time > 0) {\r\n            const chunk = time % 100;\r\n            chunks.push(chunk);\r\n            time -= chunk;\r\n            time /= 100;\r\n        }\r\n        return chunks;\r\n    }\r\n    formatTime() {\r\n        const time = this.state.timer;\r\n        const chunks = this.splitTime(time / 10).map((chunk) => {\r\n            if (chunk < 10) {\r\n                return '0' + chunk.toString();\r\n            }\r\n            else {\r\n                return chunk.toString();\r\n            }\r\n        }).reverse();\r\n        if (chunks.length === 0) {\r\n            return '00:00';\r\n        }\r\n        else if (chunks.length === 1) {\r\n            return '00:' + chunks[0];\r\n        }\r\n        else {\r\n            return chunks.join(':');\r\n        }\r\n    }\r\n    updateGame(grid) {\r\n        switch (this.state.state) {\r\n            case GameState.Won:\r\n            case GameState.Lost:\r\n                return;\r\n            case GameState.Reset:\r\n                this.startGame();\r\n                break;\r\n        }\r\n        this.setState({\r\n            grid: grid,\r\n            moves: this.state.moves + 1,\r\n        });\r\n        if (grid.isGameOver()) {\r\n            if (grid.isGameWon()) {\r\n                this.wonGame(grid);\r\n            }\r\n            else {\r\n                this.lostGame(grid);\r\n            }\r\n        }\r\n    }\r\n    render() {\r\n        return (React.createElement(\"div\", { className: \"minesweeper\" },\r\n            React.createElement(\"div\", { className: \"game\" },\r\n                React.createElement(GameTable, null, this.state.grid.getRows().map((cells, y) => {\r\n                    return (React.createElement(GameRow, { key: y }, cells.map((tuple, x) => {\r\n                        return React.createElement(GameCell, { key: x, value: tuple.value, state: tuple.state, onClick: this.handleCellClick(x, y), onRightClick: this.handleCellRightClick(x, y) });\r\n                    })));\r\n                }))),\r\n            React.createElement(\"div\", { className: \"footer\" },\r\n                React.createElement(GameStat, { value: this.state.grid.totalFlags(), name: \"Bombs\" }),\r\n                React.createElement(GameStat, { value: this.state.moves, name: \"Moves\" }),\r\n                React.createElement(GameStat, { value: this.formatTime(), name: \"Time\" }))));\r\n    }\r\n}\r\nexports.MineSweeper = MineSweeper;\r\nfunction addBombs(grid, totalBombs) {\r\n    let newGrid = new CellGrid(grid.totalRows(), grid.totalCols());\r\n    let remaining = totalBombs;\r\n    let failedGuesses = 0;\r\n    while (remaining > 0 && failedGuesses < 10) {\r\n        const x = guessBetween(0, grid.totalCols());\r\n        const y = guessBetween(0, grid.totalRows());\r\n        if (newGrid.getCellValue(x, y) !== CellValue.Bomb) {\r\n            newGrid = newGrid.setCellValue(x, y, CellValue.Bomb);\r\n            remaining--;\r\n            failedGuesses = 0;\r\n        }\r\n        else {\r\n            failedGuesses++;\r\n        }\r\n    }\r\n    return newGrid;\r\n}\r\nfunction guessBetween(low, high) {\r\n    return Math.floor(Math.random() * (high - low)) + low;\r\n}\r\nfunction addValues(grid) {\r\n    return grid.reduce((grid, x, y, cell) => {\r\n        if (cell.value === CellValue.Bomb) {\r\n            return grid;\r\n        }\r\n        else {\r\n            return grid.setCellValue(x, y, grid.countNeighborBombs(x, y));\r\n        }\r\n    }, grid);\r\n}\r\nfunction pickIcon(value, state) {\r\n    switch (state) {\r\n        case CellState.Exposed:\r\n            switch (value) {\r\n                case CellValue.Bomb:\r\n                    return 'bomb';\r\n                default:\r\n                    return CellValue[value].toLowerCase();\r\n            }\r\n        case CellState.Flagged:\r\n            return 'flagged';\r\n        case CellState.Mistake:\r\n            return 'mistake';\r\n        case CellState.Boom:\r\n            return 'boom';\r\n        default:\r\n            return 'hidden';\r\n    }\r\n}\r\n",
dependencies: ["react"],
sourceMap: {},
headerContent: undefined,
mtime: 1535400003716,
devLibsRequired : undefined,
ac : undefined,
_ : {}
}
