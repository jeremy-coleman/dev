module.exports = { contents: "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tslib_1 = require(\"tslib\");\r\nconst PlayCircleFilled_1 = require(\"@material-ui/icons/PlayCircleFilled\");\r\nconst FormatAlignRight_1 = require(\"@material-ui/icons/FormatAlignRight\");\r\nconst IconButton_1 = require(\"@material-ui/core/IconButton\");\r\nconst Close_1 = require(\"@material-ui/icons/Close\");\r\nconst mobx_react_1 = require(\"mobx-react\");\r\nconst React = require(\"react\");\r\nconst styled_jss_1 = require(\"styled-jss\");\r\nconst toaster_1 = require(\"../../components/modals/toaster\");\r\nconst core_1 = require(\"@blueprintjs/core\");\r\nconst Stack_1 = require(\"../../common/Stack\");\r\nconst _ = require(\"lodash\");\r\nconst socket_1 = require(\"../../rpc/socket\");\r\nconst theming_1 = require(\"theming\");\r\nconst RightControlBarDimensions = theming_1.withTheme(styled_jss_1.default('div')(({ theme }) => ({\r\n    maxWidth: 48,\r\n    minWidth: 48,\r\n    width: 48,\r\n    minHeight: \"100%\",\r\n    flex: \"1 1 auto\",\r\n    position: \"relative\",\r\n    display: \"flex\",\r\n    flexDirection: \"column\",\r\n    alignmentBaseline: \"central\",\r\n    overflow: \"hidden\",\r\n    border: \"3px solid white\",\r\n    boxShadow: \"0 4px 8px 0 rgba(0, 0, 0, .12), 0 2px 4px 0 rgba(0, 0, 0, .08)\",\r\n    backgroundColor: 'white',\r\n    color: theme.palette.primary.main\r\n})));\r\nlet NotebookControlBar = class NotebookControlBar extends React.Component {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.dfsPaths = [];\r\n    }\r\n    render() {\r\n        const { nodeDrawerToggle, diagramModel } = this.props.store.uiStore;\r\n        const isOrphan = (obj) => {\r\n            let isOrphan = false;\r\n            if (obj.cogType) {\r\n                obj.ports.some((port) => {\r\n                    let doBreak = false;\r\n                    if (port.name === \"leftCenter\" && port.links.length == 0) {\r\n                        isOrphan = true;\r\n                        doBreak = true;\r\n                    }\r\n                    return doBreak;\r\n                });\r\n            }\r\n            else {\r\n                if (!obj.target)\r\n                    isOrphan = true;\r\n            }\r\n            return isOrphan;\r\n        };\r\n        const isTerminalNode = (node) => {\r\n            let isTerminal = false;\r\n            if (node.cogType === \"cogliteDebug\")\r\n                isTerminal = true;\r\n            else if (node.cogType === \"cogliteFunctionMath\") {\r\n                node.ports.some((port) => {\r\n                    let doBreak = false;\r\n                    if (port.name === \"rightCenter\" && port.links.length == 0) {\r\n                        isTerminal = true;\r\n                        doBreak = true;\r\n                    }\r\n                    return doBreak;\r\n                });\r\n            }\r\n            return isTerminal;\r\n        };\r\n        const initializeDiagram = (diagram) => {\r\n            let initiatedNodes = [];\r\n            let initiatedLinks = [];\r\n            diagram.nodes.forEach((node) => {\r\n                if (!isOrphan(node)) {\r\n                    node.label = \"unexplored\";\r\n                    if (node.cogType === \"cogliteInput\")\r\n                        node.isRootNode = true;\r\n                    if (isTerminalNode(node)) {\r\n                        node.isTerminal = true;\r\n                    }\r\n                    initiatedNodes.push(node);\r\n                }\r\n            });\r\n            diagram.links.forEach((link) => {\r\n                if (!isOrphan(link)) {\r\n                    link.label = \"unexplored\";\r\n                    initiatedLinks.push(link);\r\n                }\r\n            });\r\n            diagram.nodes = initiatedNodes;\r\n            diagram.links = initiatedLinks;\r\n            return diagram;\r\n        };\r\n        const traverseModel = (diagram, nodeIndex, nodeLinks) => {\r\n            let currentNode = diagram.nodes[nodeIndex];\r\n            currentNode.label = \"visited\";\r\n            this.pathStack.push(currentNode);\r\n            if (currentNode.isTerminal) {\r\n                this.dfsPaths.push(_.cloneDeep(this.pathStack.elements()));\r\n            }\r\n            nodeLinks[currentNode.id].forEach((link) => {\r\n                let nextLink = diagram.links.find((currentLink) => currentLink.id === link.id);\r\n                let nextNodeId;\r\n                if (nextLink.label === \"unexplored\") {\r\n                    if (nextLink.source === currentNode.id)\r\n                        nextNodeId = nextLink.target;\r\n                    else\r\n                        nextNodeId = nextLink.source;\r\n                    let nextNodeIndex = diagram.nodes.findIndex((node) => node.id === nextNodeId);\r\n                    let nextNode = diagram.nodes[nextNodeIndex];\r\n                    if (nextNode.label === \"unexplored\") {\r\n                        nextLink.label = \"discovered\";\r\n                        this.pathStack.push(nextLink);\r\n                        traverseModel(diagram, nextNodeIndex, nodeLinks);\r\n                        this.pathStack.pop();\r\n                    }\r\n                    else {\r\n                        nextLink.label = \"back\";\r\n                    }\r\n                }\r\n            });\r\n            this.pathStack.pop();\r\n        };\r\n        const runModel = () => {\r\n            let serializedDiagram = diagramModel.serializeDiagram();\r\n            serializedDiagram = initializeDiagram(serializedDiagram);\r\n            console.log(serializedDiagram);\r\n            this.pathStack = new Stack_1.Stack();\r\n            this.dfsPaths = [];\r\n            const nodeLinks = {};\r\n            serializedDiagram.links.forEach(link => {\r\n                if (nodeLinks[link.source]) {\r\n                    nodeLinks[link.source].push(link);\r\n                }\r\n                else {\r\n                    nodeLinks[link.source] = [];\r\n                    nodeLinks[link.source].push(link);\r\n                }\r\n                if (nodeLinks[link.target]) {\r\n                    nodeLinks[link.target].push(link);\r\n                }\r\n                else {\r\n                    nodeLinks[link.target] = [];\r\n                    nodeLinks[link.target].push(link);\r\n                }\r\n            });\r\n            serializedDiagram.nodes.some((currentNode, nodeIndex) => {\r\n                let doBreak = false;\r\n                if (currentNode.isRootNode) {\r\n                    traverseModel(serializedDiagram, nodeIndex, nodeLinks);\r\n                    console.log(\"----The Depth First Search traversal Paths are----\");\r\n                    console.log(this.dfsPaths);\r\n                    const { nodeFormsData } = this.props.store.uiStore;\r\n                    let hasErrors = false;\r\n                    const pathSteps = [];\r\n                    this.dfsPaths.forEach((dfsPath) => {\r\n                        let currentPathSteps = [];\r\n                        dfsPath.forEach((obj) => {\r\n                            if (obj.cogType === \"cogliteInput\") {\r\n                                if (nodeFormsData[obj.cogType] && nodeFormsData[obj.cogType][obj.id]) {\r\n                                    currentPathSteps.push(\"input\");\r\n                                    currentPathSteps.push(nodeFormsData[obj.cogType][obj.id][\"inject\"]);\r\n                                }\r\n                                else {\r\n                                    hasErrors = true;\r\n                                }\r\n                            }\r\n                            else if (obj.cogType === \"cogliteFunctionMath\") {\r\n                                if (nodeFormsData[obj.cogType] && nodeFormsData[obj.cogType][obj.id]) {\r\n                                    currentPathSteps.push(nodeFormsData[obj.cogType][obj.id][\"operator\"]);\r\n                                    currentPathSteps.push(nodeFormsData[obj.cogType][obj.id][\"operand\"]);\r\n                                }\r\n                                else {\r\n                                    hasErrors = true;\r\n                                }\r\n                            }\r\n                            else if (obj.cogType === \"cogliteDebug\") {\r\n                                currentPathSteps.push(\"debug\");\r\n                            }\r\n                        });\r\n                        pathSteps.push(currentPathSteps);\r\n                    });\r\n                    if (!hasErrors) {\r\n                        console.log(\"----The value paths are----\");\r\n                        console.log(pathSteps);\r\n                        let ws = socket_1.initiateRpcClient();\r\n                        let previousValue = null;\r\n                        const executeNode = (ws, currentPath) => {\r\n                            if (currentPath.length == 0) {\r\n                                console.log(\"FUNCTION NODE TERMINALITY...\");\r\n                                console.log(previousValue);\r\n                                return;\r\n                            }\r\n                            else {\r\n                                let latestAction = currentPath.shift();\r\n                                if (latestAction === \"input\") {\r\n                                    previousValue = currentPath.shift();\r\n                                    executeNode(ws, currentPath);\r\n                                }\r\n                                else if (latestAction === \"debug\") {\r\n                                    console.log(\"DEBUG ENDPOINT\");\r\n                                    console.log(previousValue);\r\n                                    return;\r\n                                }\r\n                                else {\r\n                                    let latestValue = currentPath.shift();\r\n                                    ws.call(latestAction, [previousValue, latestValue]).then(function (result) {\r\n                                        previousValue = result;\r\n                                        executeNode(ws, currentPath);\r\n                                    });\r\n                                }\r\n                            }\r\n                        };\r\n                        pathSteps.forEach((currentPath, currentPathIndex) => {\r\n                            ws.on('open', function () {\r\n                                console.log(\"--- JSON RPC Websocket execution for path \" + currentPathIndex + \" INIT\");\r\n                                executeNode(ws, currentPath);\r\n                                console.log(\"--- JSON RPC Websocket execution for path \" + currentPathIndex + \" END\");\r\n                            });\r\n                        });\r\n                    }\r\n                    else {\r\n                        toaster_1.GlobalToaster.show({\r\n                            message: 'Please fill all the forms',\r\n                            intent: core_1.Intent.DANGER,\r\n                            action: {\r\n                                onClick: () => { },\r\n                                text: \"add text if u want here\"\r\n                            }\r\n                        });\r\n                    }\r\n                    doBreak = true;\r\n                }\r\n                return doBreak;\r\n            });\r\n        };\r\n        return (React.createElement(RightControlBarDimensions, null,\r\n            React.createElement(IconButton_1.default, { onClick: () => nodeDrawerToggle.toggleDrawer(), color: \"inherit\" }, nodeDrawerToggle.open ? React.createElement(Close_1.default, null) : React.createElement(FormatAlignRight_1.default, null)),\r\n            React.createElement(IconButton_1.default, { onClick: runModel, color: \"inherit\" },\r\n                React.createElement(PlayCircleFilled_1.default, null))));\r\n    }\r\n};\r\nNotebookControlBar = tslib_1.__decorate([\r\n    mobx_react_1.inject(\"store\", \"jsonFormsStore\"),\r\n    mobx_react_1.observer\r\n], NotebookControlBar);\r\nexports.NotebookControlBar = NotebookControlBar;\r\n",
dependencies: ["tslib","@material-ui/icons/PlayCircleFilled","@material-ui/icons/FormatAlignRight","@material-ui/core/IconButton","@material-ui/icons/Close","mobx-react","react","styled-jss","../../components/modals/toaster","@blueprintjs/core","../../common/Stack","lodash","../../rpc/socket","theming"],
sourceMap: {},
headerContent: undefined,
mtime: 1535400689296,
devLibsRequired : undefined,
ac : undefined,
_ : {}
}
