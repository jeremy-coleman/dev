module.exports = { contents: "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tslib_1 = require(\"tslib\");\r\nvar _a, _b, _c, _d;\r\nconst mobx_1 = require(\"mobx\");\r\nconst workflow_interfaces_1 = require(\"../workflow-interfaces\");\r\ntslib_1.__exportStar(require(\"../workflow-interfaces\"), exports);\r\nclass Workflow {\r\n    constructor(workflow) {\r\n        this.steps = [];\r\n        this.workflowVariables = [];\r\n        this.transient = new WorkFlowTransientState();\r\n        this.ignoreFailure = false;\r\n        this.ignoreValidation = false;\r\n        this.ignoreMissing = false;\r\n        if (workflow) {\r\n            Object.assign(this, workflow);\r\n        }\r\n    }\r\n    changeStepType(step, newStepType) {\r\n        let simpleStepTypes = ['sequential', 'service', 'parallel'];\r\n        let newStep = undefined;\r\n        if (simpleStepTypes.indexOf(newStepType) > -1) {\r\n            newStep = new WorkflowStepSimple({ name: '' });\r\n        }\r\n        else if (newStepType === 'compound') {\r\n            newStep = new WorkflowStepCompound({ name: '' });\r\n        }\r\n        if (simpleStepTypes.indexOf(newStepType) > -1 && step.type !== 'compound') {\r\n            Object.assign(newStep, step, { type: newStepType });\r\n        }\r\n        if (newStep) {\r\n            newStep.name = step.name;\r\n            let stepPos = this.findStep(step);\r\n            if (stepPos) {\r\n                this.deleteStep(step, stepPos);\r\n                stepPos.parent.steps.splice(stepPos.index, 0, newStep);\r\n            }\r\n        }\r\n        return newStep;\r\n    }\r\n    deleteStep(step, stepPos, deleteChildren = false) {\r\n        stepPos = stepPos || this.findStep(step);\r\n        if (stepPos) {\r\n            stepPos.parent.steps.splice(stepPos.index, 1);\r\n            if (step.type === 'compound' && !deleteChildren) {\r\n                let steps = step.steps;\r\n                stepPos.parent.steps.splice(stepPos.index, 0, ...(steps.map(a => a)));\r\n            }\r\n        }\r\n    }\r\n    findStep(search, parent) {\r\n        parent = parent || this;\r\n        for (var index = 0; index < parent.steps.length; index++) {\r\n            if (this.test(index, search, parent)) {\r\n                return { parent, index };\r\n            }\r\n            else if (parent.steps[index] instanceof WorkflowStepCompound) {\r\n                let childStep = this.findStep(search, parent.steps[index]);\r\n                if (childStep) {\r\n                    return childStep;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    get flattenedStepsSimple() {\r\n        return this.getFlattenedSteps(false);\r\n    }\r\n    get flattenedStepsAll() {\r\n        return this.getFlattenedSteps(false);\r\n    }\r\n    stepsBefore(step) {\r\n        if (step) {\r\n            let previousSteps = [];\r\n            let steps = this.flattenedStepsSimple;\r\n            for (let currentStep of steps) {\r\n                if (currentStep !== step) {\r\n                    previousSteps.push(currentStep);\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            return previousSteps.map(currentStep => ({ label: currentStep.name, value: currentStep.name }));\r\n        }\r\n        return [];\r\n    }\r\n    getFlattenedSteps(includeCompoundSteps = false) {\r\n        return this.flattenSteps(this.steps, includeCompoundSteps);\r\n    }\r\n    moveStep(step, index, parent = this) {\r\n        let targetEnd = index < parent.steps.length && parent.steps[index];\r\n        this.deleteStep(step, null, true);\r\n        let targetIndex = targetEnd ? parent.steps.indexOf(targetEnd) : parent.steps.length;\r\n        parent.steps.splice(targetIndex, 0, step);\r\n    }\r\n    addStep() {\r\n        let steps = this.flattenedStepsAll, name = 'New step', nameCount = 1;\r\n        while (steps.find(step => step.name === name)) {\r\n            nameCount++;\r\n            name = 'New step (' + nameCount + ')';\r\n        }\r\n        this.steps.push(new WorkflowStepSimple({ name }));\r\n    }\r\n    flattenSteps(steps, includeCompoundSteps = false) {\r\n        let flatSteps = [];\r\n        for (var i = 0; i < steps.length; i++) {\r\n            var step = steps[i];\r\n            if (step.type === 'compound') {\r\n                if (includeCompoundSteps) {\r\n                    flatSteps.push(step);\r\n                }\r\n                flatSteps = flatSteps.concat(this.flattenSteps(step.steps));\r\n            }\r\n            else {\r\n                flatSteps.push(step);\r\n            }\r\n        }\r\n        return flatSteps;\r\n    }\r\n    test(index, test, parent) {\r\n        if (typeof test === 'string') {\r\n            return parent.steps[index].name === test;\r\n        }\r\n        else if (typeof test === 'function') {\r\n            return test(parent.steps[index]);\r\n        }\r\n        else {\r\n            return parent.steps[index] === test;\r\n        }\r\n    }\r\n    static apply(source) {\r\n        let out = Object.assign(new Workflow(), {\r\n            steps: (source.steps || []).map(step => {\r\n                if (step.type === 'compound')\r\n                    return WorkflowStepCompound.apply(step);\r\n                else\r\n                    return WorkflowStepSimple.apply(step);\r\n            })\r\n        });\r\n        tryApply(out, 'workflowVariables', () => out.workflowVariables = source.workflowVariables !== undefined ? cleanKeyValueEntryArray(source.workflowVariables) : [], () => out.workflowVariables = []);\r\n        tryApplyPrimitive(out, 'ignoreFailure', source, 'boolean');\r\n        tryApplyPrimitive(out, 'ignoreValidation', source, 'boolean');\r\n        tryApplyPrimitive(out, 'ignoreMissing', source, 'boolean');\r\n        return out;\r\n    }\r\n    toJS() {\r\n        let out = {\r\n            steps: this.steps.map(step => step.toJS())\r\n        };\r\n        if (this.workflowVariables.length) {\r\n            let arr = cleanKeyValueEntryArray(this.workflowVariables);\r\n            if (arr.length) {\r\n                out.workflowVariables = arr;\r\n            }\r\n        }\r\n        if (this.ignoreFailure !== undefined) {\r\n            out.ignoreFailure = this.ignoreFailure;\r\n        }\r\n        if (this.ignoreValidation !== undefined) {\r\n            out.ignoreValidation = this.ignoreValidation;\r\n        }\r\n        if (this.ignoreMissing !== undefined) {\r\n            out.ignoreMissing = this.ignoreMissing;\r\n        }\r\n        return out;\r\n    }\r\n}\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Array)\r\n], Workflow.prototype, \"steps\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Array)\r\n], Workflow.prototype, \"workflowVariables\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Object)\r\n], Workflow.prototype, \"transient\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], Workflow.prototype, \"ignoreFailure\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], Workflow.prototype, \"ignoreValidation\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], Workflow.prototype, \"ignoreMissing\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.computed,\r\n    tslib_1.__metadata(\"design:type\", Object),\r\n    tslib_1.__metadata(\"design:paramtypes\", [])\r\n], Workflow.prototype, \"flattenedStepsSimple\", null);\r\ntslib_1.__decorate([\r\n    mobx_1.computed,\r\n    tslib_1.__metadata(\"design:type\", Object),\r\n    tslib_1.__metadata(\"design:paramtypes\", [])\r\n], Workflow.prototype, \"flattenedStepsAll\", null);\r\ntslib_1.__decorate([\r\n    mobx_1.action,\r\n    tslib_1.__metadata(\"design:type\", Function),\r\n    tslib_1.__metadata(\"design:paramtypes\", [Object, Number, Object]),\r\n    tslib_1.__metadata(\"design:returntype\", void 0)\r\n], Workflow.prototype, \"moveStep\", null);\r\ntslib_1.__decorate([\r\n    mobx_1.action,\r\n    tslib_1.__metadata(\"design:type\", Function),\r\n    tslib_1.__metadata(\"design:paramtypes\", []),\r\n    tslib_1.__metadata(\"design:returntype\", void 0)\r\n], Workflow.prototype, \"addStep\", null);\r\nexports.Workflow = Workflow;\r\nclass TransientState {\r\n    constructor() {\r\n        this.parseError = [];\r\n        this.errorsDismissed = false;\r\n    }\r\n}\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Array)\r\n], TransientState.prototype, \"parseError\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], TransientState.prototype, \"errorsDismissed\", void 0);\r\nexports.TransientState = TransientState;\r\nclass WorkFlowTransientState extends TransientState {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.parseError = [];\r\n        this.errorsDismissed = false;\r\n    }\r\n}\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Array)\r\n], WorkFlowTransientState.prototype, \"parseError\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], WorkFlowTransientState.prototype, \"errorsDismissed\", void 0);\r\nexports.WorkFlowTransientState = WorkFlowTransientState;\r\nclass WorkflowStepBase {\r\n    constructor(step) {\r\n        this.name = '';\r\n        this.transient = new TransientState();\r\n        this.name = step.name;\r\n        Object.assign(this, step);\r\n    }\r\n    static apply(source) {\r\n        return Object.assign(Object.create(WorkflowStepBase.prototype), source);\r\n    }\r\n}\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", String)\r\n], WorkflowStepBase.prototype, \"name\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", TransientState)\r\n], WorkflowStepBase.prototype, \"transient\", void 0);\r\nexports.WorkflowStepBase = WorkflowStepBase;\r\nclass StepTransientState extends TransientState {\r\n}\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", String)\r\n], StepTransientState.prototype, \"imageSourceTypeSelected\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", typeof (_a = typeof workflow_interfaces_1.HealthType !== \"undefined\" && workflow_interfaces_1.HealthType) === \"function\" ? _a : Object)\r\n], StepTransientState.prototype, \"healthCheckType\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", String)\r\n], StepTransientState.prototype, \"action\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], StepTransientState.prototype, \"healthConfigured\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], StepTransientState.prototype, \"readinessConfigured\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", typeof (_b = typeof workflow_interfaces_1.HealthType !== \"undefined\" && workflow_interfaces_1.HealthType) === \"function\" ? _b : Object)\r\n], StepTransientState.prototype, \"readinessCheckType\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], StepTransientState.prototype, \"sourceOptions\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], StepTransientState.prototype, \"failureOptions\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], StepTransientState.prototype, \"environmentConfigured\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], StepTransientState.prototype, \"volumesConfigured\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], StepTransientState.prototype, \"portsConfigured\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", String)\r\n], StepTransientState.prototype, \"sourceType\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], StepTransientState.prototype, \"explicitSourceIncludes\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], StepTransientState.prototype, \"explicitSourceExcludes\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], StepTransientState.prototype, \"explicitIncludeVariables\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], StepTransientState.prototype, \"explicitExcludeVariables\", void 0);\r\nexports.StepTransientState = StepTransientState;\r\nclass Health {\r\n    constructor(health) {\r\n        this.type = 'http';\r\n        this.headers = [];\r\n        this.transient = new TransientState();\r\n        Object.assign(this, health);\r\n    }\r\n    static apply(source) {\r\n        let health = Object.assign(new Health({}));\r\n        tryApplyEnum(health, 'type', source, workflow_interfaces_1.HealthTypes, true, () => health.type = 'http');\r\n        if (health.type === 'script') {\r\n            tryApplyPrimitive(health, 'script', source, 'string');\r\n        }\r\n        else if (health.type === 'tcp') {\r\n            tryApplyPrimitive(health, 'port', source, 'string', false, (value) => typeof value === 'number' ? value.toString() : value);\r\n        }\r\n        else {\r\n            tryApplyPrimitive(health, 'port', source, 'string', false, (value) => typeof value === 'number' ? value.toString() : value);\r\n            tryApplyPrimitive(health, 'path', source, 'string');\r\n            tryApply(health, 'headers', () => health.headers = source.headers !== undefined ? cleanKeyValueEntryArray(source.headers) : [], () => health.headers = []);\r\n        }\r\n        tryApplyPrimitive(health, 'interval', source, 'number');\r\n        tryApplyPrimitive(health, 'timeout', source, 'number');\r\n        tryApplyPrimitive(health, 'retries', source, 'number');\r\n        tryApplyPrimitive(health, 'grace', source, 'number');\r\n        return health;\r\n    }\r\n    filled() {\r\n        let keys = Object.keys(this);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            if (keys[i] !== 'transient') {\r\n                if (keys[i] === 'headers') {\r\n                    if (this[keys[i]] && this[keys[i]].length > 0) {\r\n                        return true;\r\n                    }\r\n                }\r\n                else if (keys[i] !== 'type' && this[keys[i]] !== undefined) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    toJS() {\r\n        if (!this.filled()) {\r\n            return undefined;\r\n        }\r\n        let out = fillObj(mobx_1.toJS(this));\r\n        Health.cleanupJSFields(out);\r\n        return out;\r\n    }\r\n    static cleanupJSFields(obj) {\r\n        if (obj.type === 'script') {\r\n            delete obj.port;\r\n            delete obj.path;\r\n            delete obj.headers;\r\n        }\r\n        else if (obj.type === 'tcp') {\r\n            delete obj.script;\r\n            delete obj.path;\r\n            delete obj.headers;\r\n        }\r\n        else if (obj.type === 'http' || obj.type === 'https') {\r\n            delete obj.script;\r\n            if (obj.headers && obj.headers.length === 0) {\r\n                delete obj.headers;\r\n            }\r\n            else {\r\n                obj.headers = cleanKeyValueEntryArray(obj.headers);\r\n            }\r\n        }\r\n    }\r\n}\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", typeof (_c = typeof workflow_interfaces_1.HealthType !== \"undefined\" && workflow_interfaces_1.HealthType) === \"function\" ? _c : Object)\r\n], Health.prototype, \"type\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", String)\r\n], Health.prototype, \"script\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", String)\r\n], Health.prototype, \"port\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", String)\r\n], Health.prototype, \"path\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Number)\r\n], Health.prototype, \"interval\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Number)\r\n], Health.prototype, \"timeout\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Number)\r\n], Health.prototype, \"retries\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Number)\r\n], Health.prototype, \"grace\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Array)\r\n], Health.prototype, \"headers\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", TransientState)\r\n], Health.prototype, \"transient\", void 0);\r\nexports.Health = Health;\r\nclass Readiness extends Health {\r\n    constructor(readiness) {\r\n        super(readiness);\r\n        Object.assign(this, readiness);\r\n    }\r\n    static apply(source) {\r\n        let readiness = Object.assign(new Readiness({}), super.apply(source));\r\n        tryApplyPrimitive(readiness, 'skipCheck', source, 'boolean');\r\n        return readiness;\r\n    }\r\n    toJS() {\r\n        if (!this.filled()) {\r\n            return undefined;\r\n        }\r\n        let out = fillObj(mobx_1.toJS(this));\r\n        Health.cleanupJSFields(out);\r\n        return out;\r\n    }\r\n}\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], Readiness.prototype, \"skipWait\", void 0);\r\nexports.Readiness = Readiness;\r\nclass WorkflowStepSimple extends WorkflowStepBase {\r\n    constructor(step) {\r\n        super(step);\r\n        this.type = 'sequential';\r\n        this.transient = new StepTransientState();\r\n        this.imageSource = 'image';\r\n        this.image = '';\r\n        this.dockerfile = '';\r\n        this.target = '';\r\n        this.generator = '';\r\n        this.script = '';\r\n        this.omitSource = false;\r\n        this.ignoreFailure = false;\r\n        this.ignoreValidation = false;\r\n        this.ignoreMissing = false;\r\n        this.sourceLocation = '';\r\n        this.health = new Health({});\r\n        this.readiness = new Readiness({});\r\n        this.environment = [];\r\n        this.ports = [];\r\n        this.volumes = [];\r\n        this.dockerignore = '';\r\n        this.sourceIncludes = [];\r\n        this.sourceExcludes = [];\r\n        this.includeVariables = [];\r\n        this.excludeVariables = [];\r\n        Object.assign(this, step);\r\n    }\r\n    static apply(source) {\r\n        let step = Object.assign(new WorkflowStepSimple(source));\r\n        tryApply(step, 'health', () => {\r\n            step.health = source.health !== undefined ? Health.apply(source.health) : new Health({});\r\n            if (step.health.transient.parseError.length) {\r\n                throw Error;\r\n            }\r\n        });\r\n        tryApply(step, 'readiness', () => {\r\n            step.readiness = source.readiness !== undefined ? Readiness.apply(source.readiness) : new Readiness({});\r\n            if (step.readiness.transient.parseError.length) {\r\n                throw Error;\r\n            }\r\n        });\r\n        tryApply(step, 'environment', () => step.environment = source.environment !== undefined ? cleanKeyValueEntryArray(source.environment) : [], () => { step.environment = []; });\r\n        tryApply(step, 'volumes', () => step.volumes = source.volumes !== undefined ? cleanVolumes(source.volumes) : [], () => step.volumes = []);\r\n        tryApply(step, 'ports', () => step.ports = source.ports !== undefined ? cleanPortEntryArray(source.ports) : [], () => { step.ports = []; });\r\n        tryApply(step, 'includeVariables', () => {\r\n            if (source.includeVariables !== undefined) {\r\n                if (!Array.isArray(source.includeVariables)) {\r\n                    step.includeVariables = [source.includeVariables];\r\n                }\r\n                else {\r\n                    step.includeVariables = source.includeVariables;\r\n                }\r\n            }\r\n            else {\r\n                step.includeVariables = ['*'];\r\n            }\r\n            step.transient.explicitIncludeVariables = source.includeVariables !== undefined;\r\n        }, () => step.includeVariables = ['*']);\r\n        tryApply(step, 'excludeVariables', () => {\r\n            if (source.excludeVariables !== undefined) {\r\n                if (!Array.isArray(source.excludeVariables)) {\r\n                    step.excludeVariables = [source.excludeVariables];\r\n                }\r\n                else {\r\n                    step.excludeVariables = source.excludeVariables;\r\n                }\r\n            }\r\n            else {\r\n                step.excludeVariables = [];\r\n            }\r\n            step.transient.explicitExcludeVariables = source.includeVariables !== undefined;\r\n        }, () => step.excludeVariables = []);\r\n        tryApplyPrimitive(step, 'name', source, 'string', false);\r\n        tryApplyEnum(step, 'type', source, workflow_interfaces_1.StepTypes, false);\r\n        tryApplyEnum(step, 'imageSource', source, workflow_interfaces_1.ImageSources);\r\n        tryApplyPrimitive(step, 'dockerignore', source, 'string');\r\n        tryApplyPrimitive(step, 'image', source, 'string');\r\n        tryApplyPrimitive(step, 'dockerfile', source, 'string');\r\n        tryApplyPrimitive(step, 'target', source, 'string');\r\n        tryApplyPrimitive(step, 'generator', source, 'string');\r\n        tryApplyPrimitive(step, 'script', source, 'string');\r\n        tryApplyPrimitive(step, 'omitSource', source, 'boolean');\r\n        tryApplyPrimitive(step, 'ignoreFailure', source, 'boolean');\r\n        tryApplyPrimitive(step, 'ignoreValidation', source, 'boolean');\r\n        tryApplyPrimitive(step, 'ignoreMissing', source, 'boolean');\r\n        tryApplyPrimitive(step, 'sourceLocation', source, 'string');\r\n        return step;\r\n    }\r\n    get action() {\r\n        if (this.transient && this.transient.action) {\r\n            return this.transient.action;\r\n        }\r\n        else if (this.dockerfile) {\r\n            return 'dockerfile';\r\n        }\r\n        else if (this.target) {\r\n            return 'call';\r\n        }\r\n        else if (this.generator) {\r\n            return 'generated';\r\n        }\r\n        return 'script';\r\n    }\r\n    toJS() {\r\n        let out = fillObj(mobx_1.toJS(this));\r\n        if (out.type === 'service') {\r\n            let health = this.health.toJS();\r\n            health ? out.health = health : delete out.health;\r\n            let readiness = this.readiness.toJS();\r\n            readiness ? out.readiness = readiness : delete out.readiness;\r\n        }\r\n        else {\r\n            delete out.health;\r\n            delete out.readiness;\r\n        }\r\n        if (out.type === 'sequential') {\r\n            delete out.type;\r\n        }\r\n        if (this.action !== 'script' && this.action !== 'generated') {\r\n            this.deleteScriptStepFields(out);\r\n        }\r\n        if (this.action !== 'script') {\r\n            delete out.script;\r\n        }\r\n        if (this.action !== 'dockerfile' && this.action !== 'generated') {\r\n            delete out.includeVariables;\r\n            delete out.excludeVariables;\r\n        }\r\n        else {\r\n            if (this.action !== 'generated') {\r\n                delete out.generator;\r\n            }\r\n            if (this.action !== 'dockerfile') {\r\n                delete out.dockerfile;\r\n            }\r\n            if (this.transient.explicitExcludeVariables) {\r\n                out.excludeVariables = this.excludeVariables || [];\r\n            }\r\n            if (this.transient.explicitIncludeVariables) {\r\n                out.includeVariables = this.includeVariables || [];\r\n            }\r\n        }\r\n        if (this.action !== 'call') {\r\n            delete out.target;\r\n        }\r\n        if (out.imageSource === 'image') {\r\n            delete out.imageSource;\r\n        }\r\n        if (out.environment && out.environment.length === 0) {\r\n            delete out.environment;\r\n        }\r\n        else if (out.environment) {\r\n            out.environment = cleanKeyValueEntryArray(out.environment);\r\n        }\r\n        if (out.ports && out.ports.length === 0) {\r\n            delete out.ports;\r\n        }\r\n        if (out.volumes && out.volumes.length === 0) {\r\n            delete out.volumes;\r\n        }\r\n        return out;\r\n    }\r\n    deleteScriptStepFields(step) {\r\n        delete step.environment;\r\n        delete step.generator;\r\n        delete step.health;\r\n        delete step.ignoreFailure;\r\n        delete step.ignoreMissing;\r\n        delete step.ignoreValidation;\r\n        delete step.image;\r\n        delete step.omitSource;\r\n        delete step.dockerignore;\r\n        delete step.ports;\r\n        delete step.readiness;\r\n        delete step.script;\r\n        delete step.sourceLocation;\r\n    }\r\n}\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", StepTransientState)\r\n], WorkflowStepSimple.prototype, \"transient\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", typeof (_d = typeof workflow_interfaces_1.ImageSource !== \"undefined\" && workflow_interfaces_1.ImageSource) === \"function\" ? _d : Object)\r\n], WorkflowStepSimple.prototype, \"imageSource\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", String)\r\n], WorkflowStepSimple.prototype, \"image\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", String)\r\n], WorkflowStepSimple.prototype, \"dockerfile\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", String)\r\n], WorkflowStepSimple.prototype, \"target\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", String)\r\n], WorkflowStepSimple.prototype, \"generator\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", String)\r\n], WorkflowStepSimple.prototype, \"script\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], WorkflowStepSimple.prototype, \"omitSource\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], WorkflowStepSimple.prototype, \"ignoreFailure\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], WorkflowStepSimple.prototype, \"ignoreValidation\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Boolean)\r\n], WorkflowStepSimple.prototype, \"ignoreMissing\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", String)\r\n], WorkflowStepSimple.prototype, \"sourceLocation\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Health)\r\n], WorkflowStepSimple.prototype, \"health\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Readiness)\r\n], WorkflowStepSimple.prototype, \"readiness\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Array)\r\n], WorkflowStepSimple.prototype, \"environment\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Array)\r\n], WorkflowStepSimple.prototype, \"ports\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Array)\r\n], WorkflowStepSimple.prototype, \"volumes\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", String)\r\n], WorkflowStepSimple.prototype, \"dockerignore\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Array)\r\n], WorkflowStepSimple.prototype, \"sourceIncludes\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Array)\r\n], WorkflowStepSimple.prototype, \"sourceExcludes\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Object)\r\n], WorkflowStepSimple.prototype, \"includeVariables\", void 0);\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Object)\r\n], WorkflowStepSimple.prototype, \"excludeVariables\", void 0);\r\nexports.WorkflowStepSimple = WorkflowStepSimple;\r\nclass WorkflowStepCompound extends WorkflowStepBase {\r\n    constructor(step) {\r\n        super(step);\r\n        this.type = 'compound';\r\n        this.steps = [];\r\n        Object.assign(this, step);\r\n    }\r\n    static apply(source) {\r\n        return Object.assign(new WorkflowStepCompound({}), source, {\r\n            type: 'compound',\r\n            steps: (source.steps || []).map(step => {\r\n                if (step.type === 'compound')\r\n                    return WorkflowStepCompound.apply(step);\r\n                else\r\n                    return WorkflowStepSimple.apply(step);\r\n            })\r\n        });\r\n    }\r\n    toJS() {\r\n        return {\r\n            name: this.name,\r\n            type: this.type,\r\n            steps: this.steps.map(step => step.toJS())\r\n        };\r\n    }\r\n}\r\ntslib_1.__decorate([\r\n    mobx_1.observable,\r\n    tslib_1.__metadata(\"design:type\", Array)\r\n], WorkflowStepCompound.prototype, \"steps\", void 0);\r\nexports.WorkflowStepCompound = WorkflowStepCompound;\r\nfunction fillObj(source) {\r\n    let out = {}, keys = Object.keys(source);\r\n    for (var i = 0; i < keys.length; i++) {\r\n        if (typeof source[keys[i]] !== 'function' && keys[i] !== 'transient') {\r\n            out[keys[i]] = source[keys[i]];\r\n        }\r\n    }\r\n    return out;\r\n}\r\nfunction cleanKeyValueEntryArray(source) {\r\n    let out = [];\r\n    try {\r\n        if (!Array.isArray(source) && !mobx_1.isObservableArray(source)) {\r\n            throw Error;\r\n        }\r\n        for (var i = 0; i < source.length; i++) {\r\n            if (source[i].file) {\r\n                out.push({ file: source[i].file });\r\n            }\r\n            else {\r\n                out.push({ name: source[i].name, value: source[i].name });\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        console.error(e);\r\n        throw \"Structure error parsing KeyValueEntry\";\r\n    }\r\n    return out;\r\n}\r\nfunction cleanPortEntryArray(source) {\r\n    let out = [];\r\n    try {\r\n        if (!Array.isArray(source) && !mobx_1.isObservableArray(source)) {\r\n            throw Error;\r\n        }\r\n        for (var i = 0; i < source.length; i++) {\r\n            out.push({\r\n                name: source[i].name || undefined,\r\n                internalPort: source[i].internalPort || undefined,\r\n                externalPort: source[i].externalPort || undefined,\r\n                containerPort: source[i].containerPort,\r\n                protocol: source[i].protocol || 'tcp'\r\n            });\r\n        }\r\n    }\r\n    catch (e) {\r\n        console.error(e);\r\n        throw \"Structure error parsing PortEntry\";\r\n    }\r\n    return out;\r\n}\r\nfunction cleanVolumes(source) {\r\n    let out = [];\r\n    try {\r\n        if (!Array.isArray(source) && !mobx_1.isObservableArray(source)) {\r\n            throw Error;\r\n        }\r\n        for (var i = 0; i < source.length; i++) {\r\n            out.push({ hostPath: source[i].hostPath, mountPath: source[i].mountPath });\r\n        }\r\n    }\r\n    catch (e) {\r\n        console.error(e);\r\n        throw \"Structure error parsing Volumes\";\r\n    }\r\n    return out;\r\n}\r\nfunction cleanPorts(source) {\r\n    let out = [];\r\n    try {\r\n        if (!Array.isArray(source) && !mobx_1.isObservableArray(source)) {\r\n            throw Error;\r\n        }\r\n        for (var i = 0; i < source.length; i++) {\r\n            if (source[i] !== undefined) {\r\n                if (typeof source[i] !== 'string') {\r\n                    throw \"Structure error parsing ports\";\r\n                }\r\n                out.push(source[i]);\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        throw \"Structure error parsing ports\";\r\n    }\r\n    return out;\r\n}\r\nexports.cleanPorts = cleanPorts;\r\nfunction tryApply(obj, key, fn, catchFn) {\r\n    let success;\r\n    try {\r\n        success = fn();\r\n    }\r\n    catch (e) {\r\n        success = false;\r\n    }\r\n    if (success === false) {\r\n        obj.transient.parseError.push(key);\r\n        catchFn && catchFn();\r\n    }\r\n    return success;\r\n}\r\nfunction tryApplyPrimitive(obj, key, source, type, require = false, cast) {\r\n    return tryApply(obj, key, () => {\r\n        if (require || source[key] !== undefined) {\r\n            let value = source[key];\r\n            if (cast) {\r\n                value = cast(value);\r\n            }\r\n            if (typeof value === type) {\r\n                obj[key] = value;\r\n            }\r\n            else\r\n                throw \"type error on field \" + key;\r\n        }\r\n    });\r\n}\r\nfunction tryApplyEnum(obj, key, source, enumVals, require = false, catchFn) {\r\n    return tryApply(obj, key, () => {\r\n        if (require || source[key] !== undefined) {\r\n            if (enumVals.indexOf(source[key]) > -1) {\r\n                obj[key] = source[key];\r\n            }\r\n            else\r\n                throw Error;\r\n        }\r\n    }, catchFn);\r\n}\r\n;\r\n",
dependencies: ["tslib","mobx","../workflow-interfaces","../workflow-interfaces"],
sourceMap: {},
headerContent: undefined,
mtime: 1535400690091,
devLibsRequired : undefined,
ac : undefined,
_ : {}
}
