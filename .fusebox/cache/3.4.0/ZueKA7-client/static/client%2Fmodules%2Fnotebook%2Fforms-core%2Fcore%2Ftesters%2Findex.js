module.exports = { contents: "\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst _ = require(\"lodash\");\r\nconst resolvers_1 = require(\"../util/resolvers\");\r\nexports.NOT_APPLICABLE = -1;\r\nexports.isControl = (uischema) => !_.isEmpty(uischema) && uischema.scope !== undefined && uischema.scope !== undefined;\r\nexports.schemaMatches = (predicate) => (uischema, schema) => {\r\n    if (_.isEmpty(uischema) || !exports.isControl(uischema)) {\r\n        return false;\r\n    }\r\n    const schemaPath = uischema.scope;\r\n    if (_.isEmpty(schemaPath)) {\r\n        return false;\r\n    }\r\n    let currentDataSchema = resolvers_1.resolveSchema(schema, schemaPath);\r\n    while (!_.isEmpty(currentDataSchema) && !_.isEmpty(currentDataSchema.$ref)) {\r\n        currentDataSchema = resolvers_1.resolveSchema(schema, currentDataSchema.$ref);\r\n    }\r\n    if (currentDataSchema === undefined) {\r\n        return false;\r\n    }\r\n    return predicate(currentDataSchema);\r\n};\r\nexports.schemaSubPathMatches = (subPath, predicate) => (uischema, schema) => {\r\n    if (_.isEmpty(uischema) || !exports.isControl(uischema)) {\r\n        return false;\r\n    }\r\n    const schemaPath = uischema.scope;\r\n    if (_.isEmpty(schemaPath)) {\r\n        return false;\r\n    }\r\n    let currentDataSchema = resolvers_1.resolveSchema(schema, `${schemaPath}/${subPath}`);\r\n    while (!_.isEmpty(currentDataSchema.$ref)) {\r\n        currentDataSchema = resolvers_1.resolveSchema(schema, currentDataSchema.$ref);\r\n    }\r\n    if (currentDataSchema === undefined) {\r\n        return false;\r\n    }\r\n    return predicate(currentDataSchema);\r\n};\r\nexports.schemaTypeIs = (expectedType) => exports.schemaMatches(schema => !_.isEmpty(schema) && schema.type === expectedType);\r\nexports.formatIs = (expectedFormat) => exports.schemaMatches(schema => !_.isEmpty(schema)\r\n    && schema.format === expectedFormat\r\n    && schema.type === 'string');\r\nexports.uiTypeIs = (expected) => (uischema) => !_.isEmpty(uischema) && uischema.type === expected;\r\nexports.optionIs = (optionName, optionValue) => (uischema) => {\r\n    const options = uischema.options;\r\n    return !_.isEmpty(options) && options[optionName] === optionValue;\r\n};\r\nexports.scopeEndsWith = (expected) => (uischema) => {\r\n    if (_.isEmpty(expected) || !exports.isControl(uischema)) {\r\n        return false;\r\n    }\r\n    return _.endsWith(uischema.scope, expected);\r\n};\r\nexports.scopeEndIs = (expected) => (uischema) => {\r\n    if (_.isEmpty(expected) || !exports.isControl(uischema)) {\r\n        return false;\r\n    }\r\n    const schemaPath = uischema.scope;\r\n    return !_.isEmpty(schemaPath) && _.last(schemaPath.split('/')) === expected;\r\n};\r\nexports.and = (...testers) => (uischema, schema) => testers.reduce((acc, tester) => acc && tester(uischema, schema), true);\r\nexports.or = (...testers) => (uischema, schema) => testers.reduce((acc, tester) => acc || tester(uischema, schema), false);\r\nexports.rankWith = (rank, tester) => (uischema, schema) => {\r\n    if (tester(uischema, schema)) {\r\n        return rank;\r\n    }\r\n    return exports.NOT_APPLICABLE;\r\n};\r\nexports.withIncreasedRank = (by, rankedTester) => (uischema, schema) => {\r\n    const rank = rankedTester(uischema, schema);\r\n    if (rank === exports.NOT_APPLICABLE) {\r\n        return exports.NOT_APPLICABLE;\r\n    }\r\n    return rank + by;\r\n};\r\nexports.isBooleanControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('boolean'));\r\nexports.isDateControl = exports.and(exports.uiTypeIs('Control'), exports.formatIs('date'));\r\nexports.isEnumControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(schema => schema.hasOwnProperty('enum')));\r\nexports.isIntegerControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('integer'));\r\nexports.isNumberControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('number'));\r\nexports.isStringControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('string'));\r\nexports.isMultiLineControl = exports.and(exports.uiTypeIs('Control'), exports.optionIs('multi', true));\r\nexports.isTimeControl = exports.and(exports.uiTypeIs('Control'), exports.formatIs('time'));\r\nexports.isDateTimeControl = exports.and(exports.uiTypeIs('Control'), exports.formatIs('date-time'));\r\nexports.isArrayObjectControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(schema => !_.isEmpty(schema)\r\n    && schema.type === 'array'\r\n    && !_.isEmpty(schema.items)\r\n    && !Array.isArray(schema.items)), exports.schemaSubPathMatches('items', schema => schema.type === 'object'));\r\nexports.isRangeControl = exports.and(exports.uiTypeIs('Control'), exports.or(exports.schemaTypeIs('number'), exports.schemaTypeIs('integer')), exports.schemaMatches(schema => schema.hasOwnProperty('maximum') &&\r\n    schema.hasOwnProperty('minimum') &&\r\n    schema.hasOwnProperty('default')));\r\nexports.isNumberFormatControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('integer'), exports.optionIs('format', true));\r\n",
dependencies: ["lodash","../util/resolvers"],
sourceMap: {},
headerContent: undefined,
mtime: 1535400689412,
devLibsRequired : undefined,
ac : undefined,
_ : {}
}
